   

## 一、MYSQL

### 1、什么是数据库事务？

- 数据库事务是作为一个逻辑序列，具有原子性、一致性、隔离性、持久性，意味事务在执行过程中要么操作成功，要么操作失败，保持数据的完整性。 

### 2、InnoDB于MYISAM的区别？

- InnoDB 支持事务处理，行级锁和外键，适用于需要高并发和事务处理的场景。
- MYISAM 不支持事务和行级锁，但是读取速度快，使用于密集型场景。

### 3、如何优化MYSQL查询？

- 使用合适的索引、避免在WHERE语句中使用函数、选择合适的数据类型、使用LIMIT语句减少数据量、避免全表扫描、合理设计表机构。

### 5、什么是索引？他是如何提高查询性能的？

- 索引是数据库对象，类似于书的目录，可以使数据库快速定位数据，避免扫描全表。

### 6、什么是视图，有什么优点？

- 它基于SQL命令的可视化图表、它是一个虚拟表，包含了单个或多个表中获取的数据。

  ```mysql
  -- 可更新视图（操作）简单地选择了表中的某些列，没有使用聚合函数或DISTINCT关键字，也没有GROUP BY或HAVING子句
  SELECT * FROM StudentInfo
  -- 不可更新视图（不可操作）
  -- 视图包含聚合函数（如SUM、COUNT等）。
  -- 视图包含DISTINCT关键字。
  -- 视图包含GROUP BY子句。
  -- 视图包含HAVING子句。
  -- 视图包含UNION或UNION ALL操作符。
  -- 视图是从多个表或视图中导出的。
  -- 视图中的列不是基表的列（也就是说，视-- 图中的列是通过表达式或计算得出的
  SELECT * FROM StudentInfo GROUP BY SEX 
  ```

  

- **优点：**简化复杂的SQL命令，保护数据、更改数据格式和表示等。

### 7、MYSQL中的存储过程是什么？

- 就是一组完成了特定功能的SQL语句，它存储在数据库中，可以通过指定的名词和参数进行调用，封装SQL命令进行操作。

### 8、什么是归一化（三范式），它有哪些类型？

- 归一化是设计数据库中的一个过程，用于建立两表之间的关系，目的是为了减少数据冗余性和提高数据的完整性，常见的就表结构三范式（1NF、2NF、3NF）和博耶-科得范式（BCNF）

### 9、事务隔离级别和他们如何影响并发？

- MYSQL支持四事务隔离级别类型：

- **读未提交（READ UNCOMMITTED）：**最低的隔离级别，它允许事务读取另外一个尚未提交事务的修改，这种隔离级别可能导致脏读、幻读、不可重复读，数据不一致性导致开发过程中很少使用到。

  **读已提交（READ COMMITTED）:**大部分数据库默认的隔离级别已提交（MYSQL不默认），他确保了事务只能读取其他事务已提交的最新的数据，可以防止脏读、但可能出现不可重复读和幻读。

- **可重复读（REPEATABLE READ）:**MYSQL中默认的隔离级别、在同一个事务中，多次读取同一个数据返回的结果是相同的，即使其他事务在期间修改了数据并提交，可以防止脏读、不可重复读、但可能出现幻读。

- **串行化（SERIALIZABLE）:**这是最高的隔离级别，它通过强制串行化，解决脏读、不可重复读、和幻读的问题，但由于事务需要等待其他事务先完成操作才能执行，因此该隔离级别可能会导致性能下降。

以下是三种并发问题：

- **脏读：**当一个事务读取了另一个尚未提交的事务的修改时，会发生数据是临时的或错误的，因为另外一个事务也许会回滚，就发生了脏读。
- **不可重复读：**在同一个事务内，多次读取同一个数据返回的结果有所不同，即其他事务修改了改数据，其他事务对数据进行了修改并提交。
- **幻读：**一个事务进行两次查询，但由于另外一个事务在两次查询之间插入满足所查条件的性行，因此第二次查询返回了更多的行数据，就发生了幻读。

### 10、解释MYSQL中的分区表、他是如何提高性能？

- 分区时将一个大的表分成多个小的物理技术，分区可以提高性能，因为：
- 查询可以仅在相关的一个或者多个分区上运行，而不是整个表。
- 分区也可以在磁盘上运行，提高I/0性能。

```MYSQL
`CREATE TABLE sales (
    id INT,
    year INT,
    amount DECIMAL(10,2)
)
PARTITION BY RANGE (year) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1992),
    PARTITION p2 VALUES LESS THAN (1993),
    PARTITION p3 VALUES LESS THAN (1994)
);`
```

### 11、MYSQL中如何处理死锁？

- **最小化事务大小和持续时间：**减少事务范围和减少锁的时间来降低死锁的风险。
- **避免多个事务同时运行修改相同的数据行：**设计应用逻辑，减少事务之间的交互。
- **索引的合理使用：**确保查询的高效，并尽可能使用索引，减少锁的范围。
- **检测和日志记录：**使用SHOW ENGINE INNODB STATUS命令来检查死锁记录。

### 12、什么是MYSQL二进制日志（binlogn）？

- 是MYSQL的二进制日志文件，记录数据库更改的所有操作不包括（SEELCT和SHOW），它主要用于：
- **复制：**在主复制中，通过读取和执行主服务器的binlogin来复制数据。
- **数据恢复：**在数据丢失之后恢复数据。
- **审计：**可以分析数据库活动。

### 13、MYSQL的ACID属性

ACID代表原子性、一致性、隔离性、持久性：

- **原子性：**确保事务中的操作要么全部完成，要么全部不完成。
- **一致性：**确保事务中的执行结果总是使数据库从一个有效状态到另一个有效状态。
- **隔离性：**确保并发的事务彼此独立。
- **持久性：**确保事务一旦提交，其结构永久保存在数据库中。

### 14、MYSQL中常见的性能瓶颈有哪些，如何解决？

- **硬盘I/O：**优化查询，减少不必要的数据访问，使用更快的磁盘。
- **网络延迟：**优化程序于数据库服务中间的通信。
- **查询效率：**使用索引，复杂优化，避免全表扫描。
- **锁竞争：**减少长事务，优化锁颗粒度，避免不必要的行锁。

### 15、MYSQL中的触发器类型有哪些？

- **BEFORE INSERT**：在插入操作之前触发。
- **AFTER INSERT**：在插入操作之后触发。 
- **BEFORE UPDATE**：在更新操作之前触发。
- **AFTER UPDATE**：在更新操作之后触发。
- **BEFORE DELETE**：在删除操作之前触发。
- **AFTER DELETE**：在删除操作之后触发。

共6种，每种触发器对用数据变更时执行的特定逻辑。

### 16、解释以下MYSQL中聚集索引和非聚集索引的区别？

​	聚集索引和非聚集索引的主要方式区别于数据的存储方式：

- **聚集索引：**表数据按照索引的顺序物理存储，每个表只能有一个聚集索引，通常是主键。
- **非聚合索引：**索引存储是数据逻辑顺序，而数据本身则存储在表的其他地方，非聚合索引可以有多个。

### 17、MYSQL中的非聚合索引都有哪些？

- **B树索引：**最常见的索引类型，大多数存储引擎都支持它，它能够优化值查询和范围查询，它支持多列索引，并且按照索引键值顺序排列， Y KEY、UNIQUE和INDEX等约束通常都使用B-Tree索引来实现。
- **哈希索引：**常用索引之一，哈希索引基于哈希表实现，它只适用于等值查询特别是单列的精确匹配查询，适用于字符串，整数，布尔值。
- **空间索引：**对空间类型字段创建的索引，通常用于地理信息和空间数据的存储，MYSQL中空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON，创建空间索引的列必须声明NOT NULL ,并且只能存储引擎为MYISAM的表中创建。
- **全文索引：**用于全文搜索、特别在MYISAM引擎上，它适用与大量的文本数据搜索应用。
- **R-Tree索引：**适用于空间数据查询的索引类型，它与空间索引类似，但内在中实现的新能特点不相同。
- **单列索引与多列索引：**单列索引只包含原表一个列，多列索引包含表的多个列，适用于需要多个列进行查询的场景。

### 18、MYSQL中的锁机制有哪些？

- 从锁的粒度划分，锁有行级锁、表级锁、页级锁

- **行级锁：**是锁粒度中最细的一种锁，表示只针对当前操作的进行加锁，行级锁能大大的减少数据库操作的开销，其中锁颗粒度最小，但是加锁的开销也最大！加锁慢，会出现死锁的情况，但锁定粒度最小，发生冲突的概率最低，并发度最高。

  <u>批注：最细的锁，对操作行进行加锁，开销大，加锁慢，会出现死锁，锁颗粒度小，冲突的概率小。</u>

- **表级锁：** 粒度最大的一种锁，是给整张表进行加锁，实现简单，资源消耗少，被大部分MYSQL引擎支持。

- **页级锁：**它的锁粒度介于行锁和表锁之间，表锁速度快，冲突多；行锁冲突少，但速度慢；页锁采用二者之间的方式，一次锁定一组数据，开销和开锁时间介于表锁和行锁之间，会出现死锁，并发程度一般。

- 从使用性质划分，可为共享锁、排他锁、更新锁

- **共享锁（读锁）：**S锁，又称读锁，用于只读数据操作，S锁并非独占，它允许多个事务对同一资源数据进行加锁，但是加S锁的时候就不允许加（X锁）。读取结束后立即释放，无需等待事务结束。

- **排他锁（写锁）：**X锁，又称写锁，表示对数据进行写操作，它仅允许一个事务对同一个资源进行加锁，到事务完成后才能进行释放，其他事务必须要等待X锁被释放才能进行访问。

- **更新锁：**U锁，用于对预定人员，进行加X锁，允许其他事务读取，但是不允许施加U锁或者X锁，当被读取的页将要被更新时，则升级为X锁，U锁一直到事务结束时才能被释放，故U锁用来避免使用共享锁造成死锁现象。

- 从主观划分，又可以分为乐观锁和悲观锁：

- **乐观锁：**主观认定资源会被其他事务进行修改，所以不加锁读取数据。

- **悲观锁：**主观认定资源会被其他事务进行修改，所以每次操作都会加上锁。

### 19、分库分表是什么？

- **分库：**将存储在一个数据库的数据分成多个数据库上进行存储，每个数据库可以独立部署，从而提高系统的拓展性和并发能力的处理。
- **分表：**将一个大表数据按照某种规则如（时间范围、哈希值等）分散到多个小表中，每个小表依然属于同一个数据库实例，但存储了原表的部分数据，可以减少锁竞争，优化查询新能，便于数据管理。
- **分库分表策略：**垂直拆分、水平拆分
- **垂直拆分：**将一个大表拆分成多个小表，每一个小表存储原表的一部分列，这个列适用于存储较大差异的场景，如经常访问和不常访问的列可以分开存储。
- **水平拆分：**将一个大表的数据分散到多个小表中，这适用于数据量大，读写并发高的场景。
- **注意事项：**分库分表之后，需要保持数据的一致性，事务性，路由问题，备份与恢复等。

### 20、MYSQL中in和exists的区别

- **IN：**判定某个值在一个列表内。
- **EXISTS：**关键用于检查子查询是否返回至少一行数据。
- **区别：**主要判断一个值是否在一个值内列表内，使用与静态的值列表查询。

### 21、什么是最左前缀原则？

- 最左前缀原则，在使用复合索引（包含多个列的索引），索引会按照从左到右的顺序使用索引的列，为了充分利用复合索引，查询中的条件需要匹配索引的最左侧列或其前缀。

### 22、什么是覆盖索引？

- 是指一个索引包含了查询中所有需要的所有列数据，从而避免了访问表的操作，这种索引可以显著提高查询性能，因为所有需要的数据都在索引中，可以直接从索引中获取，而不需要访问表的实际数据行。
- **优点：**提高查询性能，减少锁竞争，优化磁盘使用，占用的磁盘空间更少。

### 23、什么是索引下推？

- MYSQL5.6版本后，会在InnoDB中默认开启索引下推，在MYISAM不是默认开启，配合覆和索引进行应用，可以使用EXPLAN开查询是否开启，它通过存储引擎层过滤部分数据，从而减少服务器层需要处理的数据量，提高  查询性能。
- 允许存储引擎在扫描索引时，就应用部分Where条件，从而过滤不符合条件的数据，减少传递和处理的数据量。

### 24、什么时候不要使用索引？

1. **小表：**少量数据的表，索引的开销大于带来的性能提升，扫描全表的价值不高，会额外带来内存开销。
2. **高度更新频繁的表：**增删改查操作非常频繁的表中，索引会增加维护成本，数据每次更新，索引也要进行更新，会导致性能下降。
3. **系选择性列：**重复值很多的如性别，布尔值等，在上面建立索引的效果较差，因为索引不能有效的扫描行数。
4. **大文本二进制字段：**Text类型和Blob类型，建立索引可能导致索引体积过大，影响数据库性能。

### 25、MYSQL读写分离如何实现?

- 首先读写分离将读操作和写操作分别分配到不同的MYSQL服务器上来说实现的，这种架构可以提高数据库的性能和可用性，因为读操作比写操作频繁，分配到多个服务器上可以降低单一服务器的负载压力，当主服务器发生故障时，读操作可以继续在备份服务器上进行。

### 26、左连接和右连接有什么区别？

左右连接，他们的主要结果在于保留数据行的方向，左连接为保留左表的所有数据，即使右表没有匹配的记录，右连中，相反

### 27、使用explain命令,怎么优化sql语句.。

-   key（查看有没有使用索引）    key_len（查看索引使用是否充分）    type（查看索引类型）

### 28、存储短文本，长文本，超长文本的类型有哪些，各有什么区别？

- **短文本：**Char、varchar

  前者检索快，浪费空间，后者检索慢，省空间。

- **长文本：**text、mediumText

  内存开销问题，前者小后者大

- **超长文本：**LongText

  影响内存

### 29、索引怎么失效？

1. 不符合最左前缀原则针对：（复合索引）
2. 使用了函数或表达式
3. 使用了不等于操作符
4. 使用了OR条件
5. LIKE以通配符开头
6. 使用 IS NULL 或 IS NOT NULL
7. 数据量非常小
8. 索引列选择性差
9. 使用了ORDER BY 索引顺序不一致

**优化：**对于复杂查询，考虑使用覆盖索引。

### 30、什么情况下使用多表联查？

1. 数据分散在多个表中
2. 需要组合关联数据
3. 需要基于关联条件过滤数据
4. 需要聚合跨表查询 

