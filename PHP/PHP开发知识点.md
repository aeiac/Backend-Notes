# 一、PHP知识点

## 1、什么是面向对象？

面向对象是程序的一种设计方式，有利于提高程序的重要性，使结构更加清晰。主要特征：封装、继承、多态。

- **OOP（面向对象编程）：**使用对象来构建程序、通过对象之间的交互来实现程序的功能，实现细节，包括如何定义类、实现对象之间的交互等。
- **OOD（面向对象设计）：**注重系统开发初期，对软件整体架构和设计进行规划，在设计开发过程中，如何将系统划分成不同的对象或者组件，并确定它们之间的交互关系。

## 2、SESSION与COOKIE的区别是什么？

- **COOKIE：**存放于客户端，由浏览器负责管理。

- **SESSION：**存放于服务器端，由服务器来维护和管理。
- **区别：**
  1. **安全性：**COOKIE安全性较低、SESSION的安全性较高，攻击者需要攻击服务器才能够获取SEESION的信息，然而会话结束后，SESSION就会被销毁，这就增加了安全性。
  2. **跨域支持：**COOKIE支持跨域使用，只要COOKIE的域名和站点相同即可，SESSION只能一个站点使用，不支持跨域。
  3. **服务器压力：**访问人数较多，如果使用SESSION方式，服务器需要存储每个用户的SESSION信息，服务器压力大，而COOKIE不会。
  4. **存取方式：**COOKIE只能存储字符串，对非字符串如（Unicode或者二进制数据）需要进行转码，而SESSION可以存储任何类型的数据。

## 3、HTTP状态状态码有哪些？

**备注：**12345原则（1：消息、2：成功、3：重定向、4：客户端错误、5、服务器错误）以下是状态码列表请务必记下来。

1. **（信息性状态码）1个：**
   - **100：**继续，客户端应继续其请求。
2. **（成功状态码）7个：**
   - **200：**请求成功。
   - **201：**请求成功，服务器创建了新的资源。
   - **202：**请求成功，还未处理。
   - **203：**请求成功，返回的信息可能来自其他源。
   - **204：**请求成功，无内容返回。
   - **205：**请求成功，重置所显示内容。
   - **206：**请求成功，处理了部分GET请求。
3. **（重定向状态码）6个：**
   - **300：**请求的资源，可在多处获取。
   - **301：**永久移动到新位置。
   - **302：**暂时性转移。
   - **303：**请求被服务器接收，需要进一步才能完成请求。
   - **304：**未修改过。
   - **307：**临时重定向。
4. **（客户端错误状态码）5个：**
   - **400：** 无法理解请求格式。
   - **401：**请求未授权。
   - **403：**拒绝执行此请求。
   - **404：**找不到相匹配资源。
   - **405：**请求方式不被允许。
5. **（服务器错误状态码）5个：**
   - **500：**出现意外，请求失败。
   - **501：**不支持当前功能。
   - **502：**网关错误。
   - **503：**服务不可用。
   - **504：**请求超时。

## 4、HTTP状态中302、403、500、405代码含义？

- **302：**属于重定向队列，暂时性转移。
- **403：**拒绝执行此请求。
- **500：**出现意外，请求失败。
- **405：**请求方式不被允许。

## 5、请写出数据类型（int、 char、varchar、datetime、text）的意思，请问varchar和char有什么区别？

- **int：**整型，用于存储整数。
- **char：**定长字符，用于存储文本。
- **varchar**：**变长字符，用于存储文本。
- **datetime：**日期类型，用于存储时间。
- **`text`：**文本类型，用于存储文本。
- **区别：**char类型可定义存储长度固定存储空间，varchar类型是动态的，内容有多大就占多大的空间。

**6、isset()和empty()的作用?**

- **isset()：**判定变量是否存在，一次多个，不存在则返回false，返回则true。
- **emptry()：**判定变量是否为空，一次一个，空则返回fasle，否则则返回true。

## 7、请解释传值和中传值有什么区别？

- **传值：**会将参数复制传递给所指定函数，传递为副本，不是原始数据，不会对代码产生影响，但如果是大型数据如（数组、或者对象），那么副本会消耗大量内存和时间。
- **中传值：**直接使用原始数据不复制数据副本，从而节省内存，但也增加了代码复杂性，需要小心使用数据共享和修改使用**&符号**来引用参数，如下：

```php
function modifyArray(&$array) {  
    $array[] = 'new element';  
}  
  
$myArray = [1, 2, 3];  
modifyArray($myArray);  
print_r($myArray); // 输出: Array ( [0] => 1 [1] => 2 [2] => 3 [3] => new element )
```

## 8、PHP中的errer_reporting这个函数有什么作用？

- 设置了PHP的报错级别并放回当前级别。

## 9、语句include和require的区别是什么？

- **区别：**incluede会产生一个wanring，而require产生直接错误中断。

- require在运行前载入,include在运行时载入。
- **代替：**require_once，include_once。

## 10、foo()和@foo()有什么区别？

- 增加@忽略所有warning忽略。

## 11、简单回答PHP的垃圾回收机制

- PHP有zval用于存储类型和值，is_ref用于表示是否有别名，refcount用于表示zval中的个数，当refcount-1大于0时，会进入垃圾缓存区，当缓存积累到一定大小就会进行遍历判定是否为垃圾，从而进行释放。

## 12、echo、print_r、print、var_dump作用？

- **echo：**输出字符串。
- **print_r：**输出字符串。
- **print：**输出数组、对象。
- **var_dump：**输出数组、对象并带有数据类型。

## 13、什么是XSS攻击、CSRF攻击？

**XSS：**跨站脚本攻击，攻击者会使用恶意代码向后端发送请求鉴别在开发时留下的漏洞从而达到自己的目的，后端需要对接受到的消息进行过滤从而避免发送此类漏洞。

**CSRF：**跨站请求伪造，攻击者会使用受害者已登录的身份，构造一个恶意请求向后端发起请求，通常是一个链接或者一个表单，因为请求是受害者自己发送的，第三方网站会认为是受害者有这样的需求从而进行操作。后端需要合理规范API请求方式，对POST请求追加令牌验证等等。

## 14、$this、self、parent这三个关键词分别代表什么？

- **$this：**当前对象，在当前类中使用，使用->调用属性和方法。
- **self：**当前类中使用，不过需要使用::调用。
- **parent：**当前类的父类，在类中使用。

## 15、常用的魔术方法有哪些？，举例说明。

1. **__construct()：**实例化类时自动调用。
2. **__destruct()：**类对象结束时自动调用。
3. **__set()：**在给未定义的属性赋值的时候调用。
4. **__get()：**在调用未定义属性的时候调用。
5. **__isset()：**使用inset()和empty()函数时会调用
6. **__unset()：**使用unset()函数时会调用。
7. **__sleep()：**使用serialize序列化时会用到。
8. **__wakeup()：**使用unserialize反序列化时会用到。
9. **__call()：**调用一个不存在方法的时候调用。
10. **__callStatic()：**调用一个不存在的静态方法是调用。
11. **__toString()：**把对象转换成字符串的时候调用，比如echo。
12. **__invoke()：**尝试把对象当方法调用时用。
13. **set_state()：**使用var_export()函数时候调用。接受一个数组参数。
14. **__clone()：**当使用clone复制一个对象的时候调用。

## 16、常用的排序有哪些？

- 常见的排序算法: 冒泡排序法、快速排序法、简单选择排序法、堆排序法、直接插入排序法、希尔排序法、合并排序法。

## 17、PHP的包管理器有哪些？

1. Pear、Composer；

**为什么要使用composer？**

- **依赖管理：**增加composer.json文件，项目中所用到的项目库和依赖项，composer会自动下载安装更新这些依赖

- **自动加载：**composer具有强大的自动加载功能，遵守PSR-4标准，可以自动加载项目中的类文件。

- **版本控制：**确保使用的库版本在兼容范围内，避免由于依赖库更新导致的不兼容问题。

  

## 18、PHP中全局变量有几种？

1. **$_SERVER：**当前服务器所允许PHP脚本的环境信息。
2. **$_GET：**获取GET方法发送到当前脚本的所有参数。
3. **$_POST：**包含通过POST方法发送到当前脚本的所有参数。
4. **$_FILES：**包含通过HTTP POST方法上传的文件信息。
5. **$_COOKIE：**包含当前请求中通过HTTP Cookies发送的变量。
6. **$_SESSION：**包含与当前会话关联的数据。
7. **$_REQUEST：**包含了`$_GET`，`$_POST`和`$_COOKIE`数组中的值。
8. **$_GLOBALS：**超全局变量，它可以在整个脚本中访问所有的全局变量。

## 19、RESTful API的好处有哪些？

1. **前后端分离与流量减少：**
   - 有助于实现前后端分离，前后端可以独立开发和部署，提高开发效率。
   - 数据交互直接高效，减少不必要的流量消耗。
2. **前端无关化：**
   - Restful API使后端只负责数据处理，前端可以更加灵活，与多种客户端类型（WEB，移动应用）进行交互，无需关心后端的具体实现。
3. **安全性：**
   - 接受JSON格式的数据，有助于防止注入型问题，提高安全性。
4. **服务器性能优化：**
   - 使用简单的数据格式进行数据交互，具有轻量级的特点，从而优化服务器的性能。
5. **拓展和修改：**
   - 使用标准的HTTP方法和数据格式，因此可以容易的拓展和修改API，以满足不断变化的业务需求。
6. **易于缓存：**
   - 使用标准的HTTP协议，可以利用现有的缓存技术来提高性能和可拓展性。
7. **易于测试：**
   - 使用标准的HTTP方法和数据结构，因此可以通过浏览器和其他工具来访问和测试API，使得测试工作更加便捷。

## 20、什么是JSON，XML?

- **JSON：**是一种轻量数级数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。简单，清晰的层次结构使得JSON成为理想的数据交换语言，易于阅读和编写，同时也易于机器解析和生成，并有效的提升网络传输效率。
- **XML：**可拓展标记语言，是一种标记语言，用于定义数据结构和内容，它允许用户定义自己的标签，具有自我描述性，XML是标准通用标记语言SGML的子集，非常适合WEB传输，XML提供统一的方法来描述和交换独立于应用程序的结构化数据。具有自我描述性、结构化、灵活性、跨平台性。

## 21、为什么要选择Docker？

  作为一种新兴的虚拟化方式，Docker跟传统的虚拟化方式相比具有众多优势。

1. **更高效的利用系统资源**，容器不需要进行配置虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度，内存损耗，文件存储速度，都要比传统的虚拟机技术更高效，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。

   <u>批注：资源利用率高、执行速度快、内存损耗少、存储速度快、比旧的更快。</u>
2. **更快速的启动时间**，传统的虚拟机技术启动服务区往往需要数分钟，而Docker容器应用 ，由于直接运行于宿主内核，无需要启动完整的操作系统，可以做到秒级、甚至毫秒级启动时间，大大的节约了开发、测试、部署的时间。

3. **一致的运行环境**，开发过程中常见问题，通常是一致性问题，由于开发、测试、生产环境不一致，导致有些BUG在开发过程中未发现，而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而避免出现BUG。

4. **持续交付和部署**，一次创建在任何地方运行，使用Dokcer开使用应用通过镜像来实现集成，持续交付，部署，开发人员可以通过Docker来进行镜像构建，并结合，持续集成，系统进行集成测试，而运维人员可以直接在生产环境中部署该镜像，甚至结合持续部署系统进行自动部署。

5. **更轻松的迁移**，确保了环境的一致性，使用应用迁移更加容易，所以Docker可以在很多平台上运行，无论时物理机、虚拟机、私有云、公有云、甚至笔记本，运行结果都是一致性的，因此用户可以很轻松的将在一个平台上运行应用，迁移到另一个平台上而不用担心运行环境的变化导致软件出现无法运行的情况。

6. **更轻松的维护和拓展**，使用自带的分层存储和镜像技术，使得应用重复部署得复用更为容易，也使得应用得维护更加简单，基于基础镜像，进一步拓展镜像也变得非常简单，此为Docker团队同各个开源团队一起维护了一大批高质量得官方镜像，可以直接在生产环境中使用，又可以作为基础进一步定制，大大降低了应用服务得镜像制作成本。

7. ![image-20240505150438537](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240505150438537.png)

## 22、什么是PSR规范？

1. **PSR-1：基本编码规范**

   ​		PHP编写过程中的基本要求，包括文件命名空间，文件编码方式，类命名和文件自动加载规则等。它要求使用严格的命名空间、类和方法命名规范，以及规范的文件自动加载机制。

   - 文件名应与类名一致，使用StudlyCaps（驼峰命名法）
   - 文件拓展名必须是.php
   - 假设文件名是MyClass.php
   - 命名空间应该在文件顶部，并遵守RSP-4自动加载规范。
   - 常量必须只包含大写字母和下划线 `$CONSET_NAME`
   - 变量和方法名使用（首字母小写）`setTableStuentName(){}`

2. **PSR-2：代码风格规范**

   ​		定义了类、方法、属性等编码格式、缩进、换行、括号等。它强制使用四个空格缩进，每行最长不超过80个字符，并规定了方法之间、类成员之间应该留一个空行的规则。

   - **缩进**：代码必须使用四个空格符进行缩进，而不是使用制表符（tabs）。
   - **行长度**：每行代码的长度应限制在80个字符以内，建议不超过120个字符，但不应有硬性限制。这有助于保持代码的可读性。
   - **命名空间和use声明**：在命名空间（namespace）声明之后和use声明块之后，必须有一个空白行。
   - **大括号**：类的开始大括号 `{` 必须写在类声明后自成一行，结束大括号 `}` 也必须写在类主体后自成一行。方法的开始大括号 `{` 同样必须写在方法声明后自成一行，结束大括号 `}` 也必须写在方法主体后自成一行。
   - **可见性**：在所有的属性和方法上都必须声明可见性（即private、protected或public）。abstract和final必须声明在可见性之前；static必须声明在可见性之后。
   - **控制结构**：控制结构的关键词（如if、else、for、while等）后面必须有一个空格符。而方法和函数调用的参数列表中的逗号后面则不能有空格。

3. **PSR-3：日志接口规范**

   - 定义了一套通用的日志接口，使得不同的日志库可以互相兼容。它提供了一个简单的日志接口，用于在应用程序中进行日志记录。

4. **PSR-4：自动加载规范**

   - 将命名空间映射到文件系统中的文件路径，用于自动加载类和接口。它提供了一种标准化的方式来加载PHP类和接口，使得不同的框架和库能够更容易地集成在一起。

5. **PSR-12：扩展的代码风格规范**

   - 扩展了PSR-2，更加严格地规范了代码的编写格式，包括注释、命名规范、属性和方法的排列等。

## 23、请解释什么是中间件？

​		中间件，是操作系统和应用之间的软件组成的服务，用于处理和支持应用系统程序的运行和通信，他们通常位于系统的不同层次，用于连接，转换或增强通信和交互，中间件的作用是隐藏底系统的复杂性，提供简化的接口功能，以便于应用程序，可以更高效的的运行和交互，具体应用场景如下：

1. **通信协议转换**：将不同应用程序使用的通信协议进行转换，使它们能够相互通信。例如，将HTTP请求转换为消息队列协议，或将SOAP协议转换为RESTful协议。
2. **安全认证和授权**：提供身份验证、授权和安全访问控制，确保应用程序的安全性和数据保护。
3. **负载均衡和缓存**：分担应用程序的负载，通过缓存数据和资源来提高性能和响应速度。
4. **日志和监控**：收集、分析和记录应用程序运行时的信息和指标，以便监控和故障排除。
5. **事务管理**：处理分布式系统中的事务，确保数据一致性和可靠性。
6. **消息队列和事件驱动**：实现异步通信和事件驱动的处理，提高系统的可伸缩性和可靠性。
7. **服务间通信**：在微服务架构中，中间件可以用于管理不同服务之间的通信和交互。

**常见的中间件技术如下：**

1. **消息中间件**：

   - Apache Kafka
   - RabbitMQ
   - Apache ActiveMQ
   - NATS
   - Redis Pub/Sub

2. **Web服务器中间件**：

   - Nginx
   - Apache HTTP Server
   - Microsoft IIS (Internet Information Services)

3. **应用服务器中间件**：

   - Apache Tomcat
   - WildFly (formerly JBoss)
   - IBM WebSphere
   - Oracle WebLogic

4. **缓存中间件**：

   - Redis
   - Memcached
   - Apache Ignite

5. **API网关**：

   - Kong
   - Apigee
   - AWS API Gateway
   - Azure API Management

6. **负载均衡器**：

   - NGINX
   - HAProxy
   - AWS Elastic Load Balancer (ELB)
   - Azure Load Balancer

7. **分布式系统中间件**：

   - Apache ZooKeeper
   - etcd
   - Consul

8. **数据库中间件**：

   - MySQL Proxy
   - pgPool (PostgreSQL)
   - Oracle Data Guard

9. **身份认证和授权中间件**：

   - Keycloak
   - OAuth/OpenID Connect providers

10. **日志和监控中间件**：

    - Prometheus
    - ELK Stack (Elasticsearch, Logstash, Kibana)
    - Grafana

11. **分布式事务中间件**：

    - Atomikos
    - Bitronix

12. **容器编排和管理中间件**：

    - Kubernetes
    - Docker Swarm
    - Apache Mesos

    这些中间件技术涵盖了不同的领域，包括消息传递、负载均衡、缓存、API管理、日志和监控、分布式系统和数据库管理等。根据具体的应用需求和系统架构，选择合适的中间件技术可以帮助提升系统的性能、可靠性和扩展性。

## 24、请解释什么是解耦、削峰、异步？

- **解耦：**就是指将系统中的不同部分或模块之间的依赖关系降低最低的程度，使得各部分可以独立变更而不会影响其他部分，且能提高系统的灵活性，可维护性和可拓展性，因为减少了模块之间的耦合性，使得系统更易于理解和修改，常见得解耦方式包括使用消息队列，事件驱动架构，接口抽象等技术分离系统得各个组件，从而实现独立和拓展。
- **削峰：**应对系统在高负载时期突发流量的策略，旨在平滑负载峰值，防止系统因为高负载而导致性能下降或者奔溃。
- **异步：**在编程过程中，某些操作可以在后台并发执行，而不需要等待这些操作后再继续执行后续代码，异步编程通常用于处理需要长时间等待的I/O操作（如网络请求，文件读写，数据库查询等），以提高程序性能和响应。

## 25、什么是消息队列？

​		消息队列，是一种应用通讯，它允许不同的应用程序和组件在分布式系统中异步通讯，并通过发送、接受消息来协调和共享数据。

1. **消息：**消息是通讯的基本单元，它包含要传递的数据已相关的元数据，如消息标识、优先级、时间戳等；消息的内容可能是文本，JSON，二进制数据等，根据具体的消息队列系统和应用场景而定。
2. **消息队列：**消息队列用于存储消息的容器和服务，它通常基于先进先出（FIFO）的原则管理消息，保证消息的顺序性和可靠性。
3. **生产者：**生产者是消息的发送者，负责创建并向消息队列发送消息，通常将消息发送到特定的消息队列和主题中去。
4. **消费者：**消费者是消息的接收者，负责消息队列中订阅并处理消息，可以订阅一个或多个消息队列，并在消息到达时处理消息。
5. **队列：**队列时消息队列存储在消息中的基本单元，每个队列通常对应特定类型或用途的消息，消费者可以从队列中获取消息， 并按照特定的策略处理这个消息。

消息队列的特点和优势包括：

- **解耦性：**通过消息队列，生产者和消费者之间的通信时解耦的，他们不需要直接交互，降低列系统组件之间耦合度。
- **异步通信：**消息队列实现了异步通信，发送者和接收者可以独立运行，不需要同时在线或者都处于活跃状态。
- **削峰填谷：**消息队列可以处于平滑处理系统的流量波动，生产者可以将消息缓存到消息队列中去，而按消费者按照自身处理能力逐步处理这些消息。
- **可靠性：**消息队列系统通常具有高可用性和数据持久性的特性，可以确保消息的安全传输和可靠处理。

## 26、你常用的PHP函数有哪些？

1. **字符串处理函数：**
   - `strlen()`：返回字符串的长度。
   - `substr()`：根据坐标返回字符串。
   - `strpos()`：查找字符串首次出现的位置。
   - `str_replace()`：替换字符串中的部分内容。
   - `strtolower()`：将字符串转换为小写。
   - `strtoupper()`：将字符串转换为大写。
   - `trim()`：去除字符串中的空格。
   - `sprintf()`：格式化字符串输出。
   - `expload()`：将字符串分割成数组。
   - `impload()`：将数组元素连接成字符串。
   - `str_pad()`：填充字符串为指定长度。
   - `strcmp()`：比较两个字符串（区分大小写）。
   - `strcasecmp()`：比较两个字符串（不区分大小写）。
   - `strrev()`: 反转字符串。
   - `str_shuffle()`: 随机打乱字符串。
   - `str_repeat()`: 重复输出字符串。
   - `ucfirst()`: 将字符串首字母大写。
   - `lcfirst()`: 将字符串首字母小写。
   - **数组处理函数：**
   
   - `count()`：返回数组个数。
   - `array_push()`：向数组末尾添加一个或多个元素。
   - `array_pop()`：删除并返回数组末尾的元素。
   - `array_shift()`：删除并返回数组开头的元素。
   - `sort()`：对数组进行升序排序。
   - `rsort()`：对数组进行降序排序。
   - `asort()`：根据对关联数组进行升序排序，保持键值关联。
   - `array_map()`：将回调函数作用到数组的每个元素上。
   - `array_filter()`：根据回调函数过滤数组中的元素。
   - `array_merge()`：合并一个或多个数组。
   - `array_reverse()`：翻转数组里面所有进行翻转。
   - `array_unique()`：移除数组中重复的值。
3. **日期和时间函数**
   - `date()`：获取当前日期”Y-m-d“：年月日"H:i:s"：时分秒。
   - `time()`：获取当前时间戳。
   - `strtotime()`：将任何英文文本的日期时间描述转换为Unix时间戳。
   - `date_create()`：创建一个DateTime对象，将“年月日-时分秒”字符串进行创建。
   - `date_format()`：格式化DateTime对象。
   - `mktime($hour, $minute, $second, $month, $day, $year)`：返回特定日期的Unix时间戳。
   - `checkdate($month, $day, $year)`：检查指定日期是否有效。
4. **其他常用数组函数**
   - `die()`：输出一条消息退出当前脚本。
   - `error_log()`：发送消息到服务器的错误日志或到一个文件。
   - `phpinfo()`：查看PHP基础信息与拓展。
   - `mail()`：发送邮件。
   - `header()`：发送HTTP响应头。
5. **文件和目录操作**
   - `file_get_contents()`：将整个文件读入一个字符串。
   - `file_put_contents()`：将一个字符串写入文件。
   - `is_file()`：判定文件是否存在且是一个常规文件。
   - `is_dir()`：判断路径是否存在于一个目录。
   - `file_exists()`：判断该文件是否存在。
6. **JSON操作函数**
   - `json_encode()`：将变量转化成JSON字符串。
   - `json_decode()`：将JSON转化成变量。

## 27、PHP如何实现静态化？

​		PHP静态化通常是指将动态生成的界面内容缓存成静态文件，以减少服务器每次请求时的计算和数据库查询负载，从而提高网站的性能和响应速度，可以通过以下几种方式。

1. **使用缓存技术**

   - **Memcached**：一个高性能的内存对象缓存系统，可用于存储常用页面片段或数据。

   - **Redis**：一种内存数据存储，可以用来作为缓存存储页面内容或数据。

     ​	这些缓存系统可以将动态生成的你内容缓存起来，如何在后续请求中直接返回缓存内容，比较重复计算和数据库查询。

2. **手动实现静态化**

   ​		直接在PHP中进行编码，将动态生成的页面内容输出到静态HTML中文件去，然后在下次请求时返回，直接返回这个静态文件而需要在执行PHP代码。

3. **使用静态框架或者插件**

   - **WordPress**：有很多静态化插件可用来缓存页面，如WP Super Cache、W3 Total Cache等。
   - **Laravel**：可以使用Laravel的缓存系统或者第三方包来实现页面缓存。

4. **使用代理服务器**

   ​		你可以使用代理服务器（如Nginx、Varnish等）来缓存页面内容。当PHP动态生成页面时，代理服务器可以缓存这些内容，然后在下一次请求时直接返回缓存的结果，从而减少对PHP后端的压力。

5. **静态化的注意事项**

   - **缓存失效机制**：确保缓存的及时更新，避免展示过期或不一致的内容。
   - **动态内容处理**：某些页面可能含有一些动态内容（如用户登录状态），需要针对这些情况进行特殊处理，确保静态化不影响功能。
   - **页面清理策略**：定期清理过期或不需要的静态文件，以避免磁盘空间的浪费。

## 28、类的自动加载如何实现？

​		在PHP中，类自动加载是一种机制，它允许在使用尚未未定义的类时，自动加载这些类的代码文件，从而避免手动包含或require大量类文件。

1. 使用`spl_autoload_register()`函数

   PHP提供了spl_autolaod_register()函数，它可以注册或者多个自动加载函数，它使用尚未定义的类时，PHP将尝试调用这些函数来加载类文件。

## 29、常用的PHP开发环境有哪些？

1. LNMP、LAMP、LEMP、WAMP、MAMP、XAMPP

## 30、常用的服务端口号有哪些？

1. **80：**用于传输WEB界面。
2. **443：**用于加密的HTTP通信，提供安全的Web页面传输。
3. **21：**用于文件传输协议，用于上传和下载文件。
4. **22：**用于安全的远程登录和执行命令。
5. **25：**用于发送电子邮件。
6. **110：**用于接收电子邮件。
7. **143：**另一种用于接受电子邮件的协议。
8. **53：**用于域名解析，将域名转换为IP地址。
9. **67：**用于自动分配IP地址和其他网络配置信息。
10. **3389：**用于远程桌面连接和远程控制。
11. **3306：**用于MYSQL数据库连接和交互。
12. **5432：**用于PgSql的数据库连接和交互。
13. **27017**：由于MongoDB数据库连接和交互。
14. **6379：**用于Redis数据库连接和交互。
15. **9200：**用于Elasticsearch 数据库连接和交互
16. **123：**用于同步网络设备时间。
17. **389：**用于访问和管理目录服务。

## 31、什么是跨域请求？

​		跨域请求，实在Web'应用程序中，跨域请求时浏览器的同源策略所限制的一种行为，和其他源进行交互了具体来说，如果两个 URL 的协议、主机名（域名）、端口号中有任何一个不同，就被认为是不同源。

## 32、什么是CC攻击？

​	是指正对网络服务或者网站HTTP请求i进行大规模的恶意攻击，使用目标服务的网络带、系统资源（CPU、内存）资源耗尽，导致服务不可用或者严重受限，分布式拒绝服务攻击的一种形式，通常是由多个攻击者或者恶意机器发起的协同攻击。CC攻击的主要目的是消耗目标服务器的计算资源，网络带宽或其他系统资源、使得合法用户无法正常访问服务，常见的CC攻击手段有以下几种：

1. **HTTP Flood**： 攻击者发送大量的 HTTP 请求到目标服务器，使服务器不堪重负，无法处理正常用户的请求。攻击者可以伪造大量的 IP 地址或使用代理服务器来掩盖真实身份。
2. **Slowloris 攻击**： Slowloris 是一种特殊的 HTTP DoS 攻击方式，它利用了服务器对每个连接都会分配资源（如 CPU、内存）的特点。攻击者发送大量的 HTTP 请求，但是请求头中包含不完整的数据，同时保持连接不断开。这种方式会使服务器的连接资源被耗尽，无法响应新的合法请求。
3. **DNS Amplification**： 攻击者利用开放的 DNS 递归查询服务，向大量的 DNS 服务器发送查询请求，将查询 IP 伪造成目标服务器的 IP 地址，使得大量的 DNS 响应被发送到目标服务器，造成网络带宽和服务器资源的消耗。
4. **Botnet 攻击**： 攻击者利用大规模的僵尸网络（Botnet），控制大量感染的计算机发起协同的 CC 攻击。每台受感染的计算机可以通过恶意程序向目标服务器发送大量的请求，增强攻击效果。

## 33、简单解释一下TCP三次握手过程

- 第一次握手（SYN）：客户端请求建立连接，并向服务器发送 SYN 数据包。
- 第二次握手（SYN + ACK）：服务器接收到客户端的请求，确认请求，并向客户端发送确认和自己的 SYN。
- 第三次握手（ACK）：客户端接收到服务器的确认，向服务器发送确认，双方建立连接。

## 34、什么是**B2B、B2C、C2C、O2O、Saas**

1. **B2B：**企业对企业，电子商务交易的供需双方都是商家、企业、公司，利用互联网技术的各种商务平台完成商务交易，电子商务是现代B2B营销的具体和主要表现，例如现在的阿里巴巴、1688等平台。
2. **B2C：**企业对个人，企业对客户就是一种电子商务的模式，直接面向消费者销售和服务，如天猫，京东等。
3. **C2C：**个人对个人，消费者有一台电脑，通过网络进行交易、如何卖给另外一个消费者，就是C2C电子商务、C2C电子商务主要是指网上拍卖，像淘宝，拼多多，大部分都是由个体户在售卖商品，并不是企业。
4. **O2O：**线上对线下，或者线下对线上，是指线下的商务机会与互联网结合，让互联网成为线下交易的平台，O2O的核心是把线上的消费者带到现实中的商店中去，也就是让客户在线上购买商品、服务之后，去线下门店消费，享受服务。
5. **CRM：**即客户管线管理，经销商需要做好客户关系管理、加强与下游的链接，提升顾客的体验的同时，才能最大挖掘客户价值。
6. **SRM：**供应商管理，SRM的最基本内容就是供应商分类选择，战略关系发展，供应商谈判和供应商绩效评价四个方面，企业使用SRM软件就是为了做好多供应商管理。
7. **ERP：**企业资源计划，ERP系统是指建立在信息技术基础上，集信息技术与先进管理思想于一身，系统化的管理思想，为企业员工决策层提供决策手段的平台，有生产资源计划、制造、财务、销售、采购等功能外，还有质量管理，实验室管理，业务流程管理，产品数据管理，存货，分销于运输管理，人力资源管理和定期报告系统。
8. **WMS：**仓库管理系统、为企业搭建一个灵活的精细化的库存管理平台，有效提升仓储效率。
9. **SaaS：**软件服务，通过网络提供的软件服务，SaaS平台供应商将应用软件统一部署在自己的服务器上，客户可以更具工作实际需求，通过互联网向厂商订购所需要的应用软件服务，按订购的服务多少和时间长短向厂商支付费用，并通过互联网获取SaaS平台供应商提供的服务。
10. **PaaS：**平台即服务**，指把服务器平台作为一种服务提供的商业模式，通过网络进行程序提供的服务称之为SaaS，而云计算时代相应的服务器平台或者开发环境作为服务进行提供就成为了PaaS。
11. **IaaS**（Infrastructure as a Service），**基础设施即服务**，把IT基础设施作为一种服务通过网络对外提供，并根据用户对资源的实际使用量或占用量进行计费的一种服务模式；用户无需自建一个数据中心等硬件设施，而是通过租用的方式，利用 Internet从IaaS服务提供商获得计算机基础设施服务，包括服务器、存储和网络等服务。

## 35、什么是JWT？



JWT数字签名由三部分组成，使用点号分割：

1. **Header（头部）：**包含令牌的类型（JWT）使用的签名算法如（HMAC，SHA256，RSA）。
2. **Payload（负载）：**包含要传输的声明或信息，比如用户ID、用户名、角色等
3. **Signature（签名）：**使用指定的算法对头部和载荷进行计算，以确保数据的完整性和真实性。

## 36、异步和同步的区别？

​		异步和同步是两种不同的编程模型，用于描述程序中的不同操作之间的执行方式和时间序列。

- **同步：**在同步模型中，在一个操作发起时，调用者会被阻塞，直到操作完成并返回结果，然后才继续下一个操作，在同步模型中，按照代码的编写顺序依次执行，每个操作必须等待前一个完成才能执行。

  - 调用者会被阻塞，知道操作完成。
  - 按照顺序执行，每个操作必须等待钱一个操作的完成。
  - 程序执行流程直观，易于理解和调节。

- **异步：**在异步模型中，当一个操作发起时，调用者不会被阻塞，二继续执行后续的操作，操作时的完成状态不影响后续代码，当操作完成后，会通过回调函数，事件或者其他方式来通知调用者。

  - 调用者不会 被阻塞，可以继续执行后续操作。
  - 可以并发执行多个操作，操作的完全顺序不受控制。
  - 需要通过回调函数，时间监听等方式来处理操作完成通知，处理流程相对复杂。

  **区别：**

  - **阻塞和非阻塞：**同步模型之下，调用者不会被阻塞，必须等待操作完全之后才能继续执行后续代码。异步模型下，调用者不会被阻塞，可以继续执行后续代码，代操作完成后通过回调时间处理结构。
  - **顺序与并发：**同步下，操作按照顺序依次执行，每个操作必须等待上一个操作完成。异步下，可以并发执行多个操作，操作的完成顺序不受控制。
  - **代码流程：**同步下代码执行流程直观，按照代码顺序执行，易于理解和调式。异步下，代码流程相对复杂，需要处理回调，事件等异步操作的结果。

## 37、如何使用缓冲区？


​		输出缓冲区在 PHP 中是一个用来临时存储输出内容的机制。它的作用是将 PHP 脚本生成的输出先保存起来，而不是立即发送到浏览器，这样可以在适当的时机对输出内容进行处理或修改，或者将其作为整体输出，从而提供更灵活的控制和优化输出流程的方式。

以下是缓冲区的几个常见用途和好处：

1. **性能优化**：
   - 缓冲区可以减少服务器与客户端之间的数据传输次数，提高页面加载性能。当所有输出被收集到缓冲区后，可以在确定所有处理都已完成后，一次性将结果发送给客户端，减少网络延迟。
2. **输出内容的处理**：
   - 使用缓冲区可以在输出内容到浏览器之前对其进行处理，比如在输出之前修改部分内容、添加特定标记或进行其他操作，从而灵活控制页面输出的最终形式。
3. **减少重复计算**：
   - 将动态生成的内容先保存在缓冲区中，可以避免重复计算或查询数据库，提高页面响应速度。特别是对于动态内容不经常变化的部分，可以缓存起来供后续请求使用。
4. **处理头信息**：
   - 输出缓冲区可以在发送任何内容之前设置 HTTP 头信息，如设置 Cookie、设置响应状态码等，确保头信息不会在输出开始后被发送，避免出现错误。
5. **避免“头信息已发送”错误**：
   - 在 PHP 中，一旦开始向浏览器输出内容，就无法再设置头信息，否则会导致“头信息已发送”错误。使用缓冲区可以确保所有的输出和头信息都在需要的时候一起发送。

在 PHP 中，使用缓冲区可以通过以下函数实现：

- `ob_start()`: 启动输出缓冲。
- `ob_end_flush()`: 输出缓冲区内容并关闭缓冲区。
- `ob_get_contents()`: 获取缓冲区的内容而不清空缓冲区。
- `ob_clean()`: 清空输出缓冲区而不关闭它。
- `ob_end_clean()`: 关闭输出缓冲区并丢弃缓冲区中的内容。

## 38、PHP的变量作用域主要有哪些？

- **局部作用域：**局部作用域是在函数和方法内部声明的变量，函数或方法执行结束之后，这些变量就会被销毁。
- **全局作用域：**全局是指在函数和方法之外声明的变量，可以在PHP脚本的任何地方进行访问，但要在函数或方法内使用全局变量需要加上关键字global或￥GLOBAL数组。
- **静态作用域：**使用static关键字，他的生命周期贯串整个脚本的整个执行周期，但他们的作用域仅限于定义它们的函数内部，静态变量在函数调用结束后不会被销毁，下次调用该函数的时候这边变量将保持上次调用结束时的值。
- **参数作用域：**就是传参，它们的作用域与函数内部。
- **超全局作用域：**PHP提供了一些预定义数组，这些数组可以在任何一个脚本中访问到，如$_GET等。

## 39、继承关键词继承父类用什么，继承接口用什么？

Extens

## 40、接口类和抽象类是怎么定义的，有什么区别？

- **abstract （抽象类）：**
- **interface （接口象类）：**类通过implements 进行继承，调用

## 41、5.6、7.0、8.0等PHP版本的特性

**PHP5.6：**

- **常量数组支持：**可以定义常量数组，使用 `define()` 函数。
- **变量解包：**支持变量解包，允许使用运算符。
- **异常处理：**改进异步处理机制，支持在Catch中捕获多个异常类型。

**PHP7.0：**

- **性能提升：**整体性能提升两倍。

- **标量类型声明：**支持标量类型声明，可以声明参数和返回值的类型。

  ```php
  function sum(int $a, int $b): int {    
      return $a + $b; 
  }
  ```

- **返回类型声明：**函数返回值类型声明。

  ```php
  function getValue(): string {    
      return "Hello"; 
  }
  ```

- **新运算符：**引入??空合运算符，简化代码。

  ```php
  $value = $array['key'] ?? 'default';
  ```

- **异步处理改进：**引入Error类，提供更好的错误处理。

**PHP 8.0：**

- **JIT：**即时编译。

- **命名参数：**支持函数调用中使用命名参数，提高可读性。

  ```php
  function foo($a, $b, $c) { ... } 
  foo(c: 3, a: 1, b: 2);
  ```

- **联合类型：**支持联合类型声明，允许参数和返回值可以是多种类型。

  ```php
  function test(int|string $value) { ... }
  ```

- **属性推广：**在构造函数中自动初始化属性，减少样板代码。

  ```php
  class User {
      public function __construct(public string $name) { } 
   }
  ```

- **Match表达式：**

  ```php
  $result = match($input) {    
  1 => 'one',    
  2 => 'two',    
  default => 'other', 
  };
  ```

- **改进类型系统：**增强类型检查，支持更严格的类型转换。

