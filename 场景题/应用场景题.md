<center>场景应用<center>

# 一、SQL与NOSQL

## 1、SQL和NOSQL 怎么保持数据一致？

**写入后同步**：

- 在对 MySQL 进行写操作（如插入、更新、删除）后，立即更新 Redis 中的相应数据。这种方式确保 Redis 中的数据与 MySQL 同步。

**缓存失效**：

- 在更新 MySQL 后，主动删除 Redis 中的缓存数据。下次访问时，系统会重新从 MySQL 中加载数据并更新缓存。

**使用消息队列**：

- 通过消息队列（如 RabbitMQ、Kafka）来异步处理数据更新。当数据在 MySQL 中发生变化时，发送消息到队列，消费端根据消息更新 Redis。

**定期同步**：

- 定时任务定期从 MySQL 中同步数据到 Redis，适合数据更新不频繁的场景。

**版本控制**：

- 在 Redis 中维护版本号或时间戳，在每次更新时比较版本，以决定是否更新缓存。

## 2、Redis淘汰策略

1. **noeviction：**达到内存最大限制时，禁止写入操作，返回错误，默认策略。
2. **allkey-lru：**所有key，无论是否设置过期时间，当需要释放内存时，最近最少访问的key，优先删除，以便腾出新空间。
3. **volatile-lru：**仅对设置了过期时间的键采用 LRU 淘汰策略。
4. **allkeys-random：**随机删除key释放内存。
5. **volatile-random：**随机删除一个设置过期时间的key释放内存。
6. **volatile-ttl：**优先删除即将过期的key，选择过期时间最短的key。
7. **allkeys-lfu**：在所有键中使用最不常用（LFU）算法淘汰键。
8. **volatile-lfu**：仅对设置了过期时间的键使用 LFU 淘汰策略。

**LRU 原则**：需要释放内存，Redis查找最近最少访问Key，优先删除Key，释放空间。

**LFU 原则**：缓存淘汰算法，优先淘汰使用最低的Key，追踪数据的访问次数次数定义淘汰。

# 二、并发与异步编程

