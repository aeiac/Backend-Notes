# **Redis知识点**

**简介：**

​		概括了解noSQL的概，目前数据库分为关系型和非关系型；其中常用关系型数据库为：Oracle、MYSQL、SQLServer、Neo4j；非关系数据库有：Redis、MongoDB等，NoSQL新的名词：non-relatioonal 没有SQL语句“Not Only SQL ”不使用SQL命令的数据库。

​		二者的区别为，NoSQL存储于内存（RAM）它的读写速度快但是存储空间小，SQL存储于硬盘（ROM）它的读写速度没有前者快，但是存储空间大。

​		非关系数据库经常用到，电子商城商品详情、排行榜、数据统计、计数、缓存层、分布式会话（聊天、系统之间实时消息传送）；

## **一、Redis基础知识点**

### 1.1、缓存穿透

​		调用接口查询一个不存在的数据库，这个数据不存在缓存中，导致越过Redis直接去关系型数据库查询，数据库中也没有这个数据库，但数据库中也没有这个数据，这样就造成“缓存穿透”，如果有大量这样的请求，会给关系型数据库带来很大的压力。

**解决策略**：

- **布隆过滤器**：使用布隆过滤器，对不存在的数据进行过滤，从而避免对数据库的查询。
- **缓存空对象**：对于不存在的数据，也在缓存中存放一个空对象或特定标识，但其过期时间会很短。
- **接口限流与熔断**：限制查询的频率，对于超过阈值的请求进行熔断处理。

### 1.2、缓存击穿

​		缓存击穿是指某个热点数据（在高并发访问的数据库）在缓存中也到期了，此时大量访问这个数据这查询数据库，导致数据库压力瞬间增大。

**解决策略**：

- **互斥锁**：在缓存失效的时候，不是立即去加载数据库数据，而是先使用缓存工具的某些特性（例如Redis的setnx）来设置一个锁，当其他线程发现已经有锁存在的时候，则放弃此次查询，或者去尝试获取这个锁，当获取到锁的时候，再去加载数据。
- **热点数据永不过期**：对于某些热点数据，可以将其在缓存中的过期时间设置为一个较大的值，或者永不过期。

### 1.3、缓存雪崩

​		缓存雪崩是指大量缓存数据在同一时间过期（例如：设置了相同的过期世间），导致大量的请求都去数据库中请求查询这些数据库，使数据库瞬间承受巨大的压力。

**解决策略**：

- **随机过期时间**：为每个缓存数据设置不同的过期时间，避免它们在同一时间过期。
- **缓存预热**：在系统启动或低峰期时，预先加载一些热点数据到缓存中。
- **监控与报警**：对缓存的命中率和数据库查询量进行监控，当发现缓存命中率大量下降或数据库查询量异常增加时，及时报警并进行处理。

### 1.4、死锁

**简介：**死锁是指在客户端进程并发操作，由于某种原因（如资源互斥、请求顺不当等）导致他们相互等待对方释放资源， 从而使整个系统无法继续执行操作现象，当死锁发生时，相关客户端的进程会被阻塞，无法完成正常操作，直到死锁被解决完成。

为了避免Redis中的死锁问题，可以采取以下措施：

1. 合理使用锁机制：确保锁的粒度适中，避免过细或过粗的锁粒度。同时，要确保锁的释放逻辑正确，避免因为程序异常或崩溃而导致锁无法释放。
2. 设置合理的超时时间：为锁设置一个合适的超时时间，确保在客户端无法及时释放锁的情况下，锁能够自动超时释放，从而避免死锁的发生。
3. 限制并发连接数：通过合理配置Redis服务器的最大并发连接数，避免过多的并发操作导致资源竞争和死锁问题。
4. 使用乐观锁机制：在并发操作中，可以采用乐观锁机制来避免冲突。通过版本号或时间戳等方式来判断数据是否发生变化，从而避免不必要的加锁操作。

### 1.5、锁机制

#### 1.5.1、乐观锁

​		并发控制的策略，它基于一种假设、即使在大多数情况下，数据不会被其他线程占用或者修改，因此，当需要对-**数据**-进行修改时，乐观锁不会立即锁定数据，而是直接进行修改，并在提交更新时检查数据是否在期间被其他事务修改过。

​		在Redis中，乐观锁的实现通常依赖于WATCH命令和事务。WATCH命令用于监视一个或多个键，当这些键的值在执行事务之前被其他客户端修改时，Redis会取消事务的执行，并通知客户端。这样，客户端可以在检测到冲突后重新尝试执行事务，或者采取其他适当的措施。

**乐观锁的使用场景主要包括：**

1. **商品库存管理**：在电子商务应用中，乐观锁可以有效地防止超卖问题。当多个用户尝试购买同一商品时，可以使用乐观锁来确保库存数量的正确性。具体地，每次进行库存扣减操作时，先使用WATCH命令监视库存键，然后在事务中执行库存扣减。如果事务执行期间库存键被其他客户端修改（即其他用户也购买了该商品），则Redis会取消该事务的执行，客户端可以重新尝试或采取其他措施。
2. **分布式系统中的数据更新**：在分布式系统中，多个节点可能需要对共享资源进行并发更新。使用乐观锁可以确保在更新过程中不会发生数据冲突。例如，可以使用WATCH命令监视共享资源键，并在事务中执行更新操作。如果事务执行期间该键被其他节点修改，则Redis会取消事务执行，从而避免数据不一致的问题。
3. **多用户协同编辑**：在协同编辑应用中，多个用户可能同时编辑同一份文档。使用乐观锁可以在用户提交更改时检查文档版本，以确保不会发生冲突。如果文档在编辑过程中被其他用户修改，乐观锁会检测到冲突，并允许用户解决冲突后重新提交更改。

<u>**备注：先修改，在检查是否被其他事务修改。**</u>

#### 1.5.2、互斥锁

​		在缓存失效的时候，不是立即去加载数据库数据，而是先使用缓存工具的某些特性（例如Redis的setnx）来设置一个锁，当其他线程发现已经有锁存在的时候，则放弃此次查询，或者去尝试获取这个锁，当获取到锁的时候，再去加载数据。

Redis互斥锁的应用场景非常广泛。以下是一些常见的应用场景示例：

1. **分布式事务控制**：在分布式系统中，多个进程或线程可能需要协同完成某项任务。通过使用Redis互斥锁，可以确保在特定时间段内只有一个进程或线程能够执行关键操作，从而避免数据竞争和不一致性问题。
2. **缓存更新**：当多个客户端同时尝试更新Redis中的缓存数据时，互斥锁可以确保每次只有一个客户端能够执行更新操作。这有助于防止缓存数据被意外覆盖或损坏。
3. **限流与防刷**：在高并发的场景下，为了保护系统免受过多的请求冲击，可以使用Redis互斥锁来实现限流功能。通过限制同时获取锁的客户端数量，可以控制并发请求的数量，从而避免系统过载。
4. **用户注册与登录**：在处理用户注册或登录请求时，为了避免多个用户同时注册同一个账号或同时登录同一个账号，可以使用Redis互斥锁来确保同一时刻只有一个请求能够执行。

**<u>备注：你请求成功，别人就请求失败，一个一个来</u>**

#### 1.5.3、悲观锁

悲观锁在操作数据时持保守态度，认为其他线程会修改数据。因此，在操作数据时，它会先锁定数据，直到操作完成。这种锁机制常用于写操作较多的场景，以确保数据在写操作时的正确性。

以下是一些悲观锁的具体应用场景示例：

1. **金融交易系统**：在金融领域中，如银行转账、证券交易等场景，对数据的一致性和准确性要求极高。由于这些操作往往涉及资金的变动，因此需要使用悲观锁来确保在交易过程中数据不会被其他事务修改，从而避免出现资金错误或不一致的情况。
2. **库存管理系统**：在电商或零售行业中，库存的实时同步和准确性对于业务至关重要。当多个用户或系统同时尝试修改库存数量时，使用悲观锁可以确保每次只有一个操作能够成功执行，从而避免超卖或库存不一致的问题。
3. **订单处理系统**：在订单处理过程中，可能需要多个步骤和多个系统的协同工作。为了避免在订单状态更新、库存扣减等关键步骤中出现数据冲突，可以使用悲观锁来锁定相关资源，确保同一时间只有一个操作能够执行。
4. **数据迁移和备份**：在进行大规模数据迁移或备份时，需要确保数据的完整性和一致性。通过使用悲观锁，可以在迁移或备份过程中锁定相关数据，防止其他操作对其进行修改，从而确保数据的准确性和可靠性。

<u>**备注：**Redis不支持悲观锁，先锁死，在修改</u>

#### 1.5.4、读锁

读锁（也称为共享锁）主要用于不更改或不更新数据的操作（只读操作），如SELECT语句。多个线程可以同时持有读锁，以并发地读取数据。

#### 1.5.5、写锁

写锁（也称为排他锁）用于数据修改操作，如INSERT、UPDATE或DELETE。当一个线程持有写锁时，其他线程无法对数据进行修改，以确保数据的一致性。

#### 1.5.6、锁命令

- **SETNX命令**：SETNX是Redis原子操作，用于KEY-VALUE不存在时设置值，如果设置成功则返回1（True），设置失败则返回0（False）KEY-VALUE已存在，这方式简单直接，但需要注意合理的过期时间，避免死锁。

- **RedLock算法：**RedLock算法是一种基于多个Redis缓存节点实现分布式锁的实现方式，它要求在客户端在多个独立的Redis节点上获取锁，只有大多数节点都成功获取锁时，才认为锁成功获取，这种 方式提高了锁的容错性，但也需要更多的Redis节点和更复杂的实现。

- **Lua脚本**：Redis支持执行Lua脚本，可以利用Lua脚本的原子性来实现更复杂的锁机制。例如，可以使用Lua脚本先检查键是否存在，如果不存在则设置其值并返回成功，否则返回失败。这种方式可以避免多次网络往返，提高性能。

  在使用Redis锁时，需要注意以下几点：

- **设置合理的过期时间**：为了避免死锁，需要为锁设置一个合理的过期时间。当锁过期后，其他客户端可以重新获取锁。

- **续签锁**：如果业务操作耗时较长，可能导致锁在过期前仍未完成。为了解决这个问题，可以在持有锁的客户端中开启一个定时任务，定时更新锁的过期时间，以保证锁的持续有效。

- **避免锁粒度过大**：锁的粒度越大，竞争就越激烈，性能就越差。因此，应该尽量减小锁的粒度，只锁定需要同步访问的资源部分。

### 1.6、数据持久化

#### 1.6.1、RDB

创建内存文件存储数据快照，当Redis需要执行持久化时，它会创建内存数据库的快照保存在硬盘上。

**优点：**RDB是一个二进制文件，它存储了Redis在某个时间点上的全部快照；它非常适合用于数据备份，因为RDB文件是完整的数据库快照，可以很容易的复制道其他服务器或者位置；它生成和加载都很快，在大型数据库集上也能保持较高的性能。

**缺点：**定时持久化，如Redis突然宕机，可能会丢失最后一次快照的所有数据，RDB在数据量大的时候，fork进程可能会消耗较多资源。

#### 1.6.2、AOF

是通过记录所有写的命令来完成的，当Redis只是一个写命令时，这个命令就会被追加道AOF文件的末尾，这样，即使Redis宕机，也可以重新执行AOF文件中的命令来恢复数据。

- **优点：**AOF持久化提供了更高的数据可靠性，因为所有的写命令都会被记录下来；AOF文件是一个追加写入日志文件，通常写入性能会被RDB的快照生成高，AOF文件是一个文本文件，可以通常编辑它来修复错误命令。
- **缺点：**AOF比RDB文件大，在恢复数据时，AOF会执行所有写命令，这会让它加载比RDB慢，为了保持数据持久性，AOF持久化可能还会带来一些性能损耗，因为每次写命令都要追加到AOF文件中。

Redis 允许用户同时开启 RDB 和 AOF 持久化，Redis 会优先使用 AOF 文件来恢复数据，因为 AOF 的数据通常更加完整。在实际应用中，可以根据业务需求和系统性能来选择合适的持久化策略。例如，对于需要高可靠性的系统，可以开启 AOF 持久化；对于需要快速恢复的系统，可以开启 RDB 持久化，并定期生成快照备份。

### **1.7、数据类型**

#### 1.7.1、String

​		字符串类型，可以存储任意类型的数据，如文本、数字、图片或者序列化的对象，其Value的本质就是字符串，一个String类型的剪纸最大可以存储512MB的数据。

**应用场景：**商品库存、用户信息、排行榜等，网站访问量、文章的查看次数、点赞等。每次请求操作时只需要+1即可。

- **String操作命令：**

  ```Redis
  #获取字符串长度
  STRLEN keyName
  #追加值到字符串
  APPEND KeyName "内容"
  #设置并返回旧值
  APPEND KeyName "新值"
  #递增数值+1，用于整数
  INCR KeyName 
  #递减数值-1，用于整数
  DECR KeyName
  ```

  

#### 1.7.2、Hash

​		数据结构、它键值对的存储数据关系，适合存储对象，在Hash中，每一个id都对应一个Value，这种映射关系的存储适合Hash类型存储查询复杂的结构化时非常高效，Hash的存储数据都是二进制存储，意味着它可以包含任何数据类型，包括二进制类型。每一个Hash类型可以存储超过4亿个键值对，无论Hash中存储了多少个数据，查询某个键的速度都是非常快的。

**应用场景：**可以将对象的属性作为Hash的field，属性值作为Hash的value。例如，存储用户信息时，可以将用户的姓名、年龄、性别等属性以键值对的形式存储在Hash中；Hash类型也可以用于缓存一些计算结果或查询结果。通过存储计算结果或查询结果的Hash值，可以在下次需要时直接查找，避免重复计算或查询数据库。

**Hash操作命令**

```redis
#设置哈希字段的值
HSET UserInfo name "zbc"
#获取哈希字段的值
HGET key name
#获取哈希中所有字段和值
HGETALL key

```



#### 1.7.3、List

​		双向链表，它支持列表两端插入和删除，并且在列表中的元素是有序的，按照插入的顺序进行排序，这种特性使得list在多种场景中都有使用，可以根据索引来访问列表中的元素，List列表中元素是可以重复的，可以从头部或者尾部开始插入和删除元素，这样的特性使得list在处理一些需要频繁在两端操作的场景时非常高效。

**应用场景：**

1. **任务队列**：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此List常被用来实现任务队列。生产者可以将任务推入List，而消费者则可以从List中取出任务进行处理。
2. **消息通知**：与任务队列类似，List也可以用来实现消息通知系统。当有新的消
3. 息或事件产生时，可以将其推入List，然后通知相关的客户端从List中获取并处理这些消息。
4. **实现日志记录**：Redis的List可以用来存储日志记录。通过不断地将新的日志条目推入List，可以实现对日志的实时收集和管理。
5. **缓存淘汰策略**：虽然Redis本身提供了键的过期时间设置来实现缓存淘汰，但在某些复杂的场景下，也可以使用List来实现更复杂的缓存淘汰策略。
6. **轮询队列**：Redis的List还可以用来实现轮询队列，例如在某些需要按照特定顺序或规则处理任务的场景中。

**列表命令**

```
#左侧添加推入列表
LPUSH key Value
#右侧添加推入列表
RPUSH key Value
#从左侧弹出元素
LPOP key
```



#### 1.7.4、Set

集合是无序的，并且集合中的元素是唯一的，不存在重复的数据，Set类型提供了丰富的操作来处理集合数据，比如添加、移除、获取集合成员，判断成员是否存在等。

**应用场景**

SET类型的数据结构在Redis中有广泛的应用场景，包括：

- 用户标签系统：每个用户可以有一组标签，标签集合可以用SET来存储。
- 社交应用中的好友列表或关注列表。
- 存储一个对象的唯一ID集合，例如，存储所有在线用户的ID。
- 用于数据去重，例如在处理大量数据时，可以先将数据添加到SET中，以自动去除重复项。

**集合命令：**

```
#向集合添加成员
SADD key Mmber
SADD animals "cat"
SADD animals "dog"
SADD animals "bird"
集合 animals 包含 {"cat", "dog", "bird"}。
#移除集合中的成员
SREM KEY MEMBER
SREM animals "bird"
集合 animals 包含 {"cat", "dog"}。

```



#### 1.7.5、Zset

有序集合，每个元素都是唯一的，并且与Set不同，Zset为每一个元素都关联了一个双精度浮点型的分数，正是这个分数为Zset中的元素提供了一个顺序，并且从小到大，如果在集合中多个元素有相同的分数那么Zset会根据字典进行排序。

 **应用场景**

在实际应用中，Zset可以用于实现各种需要排序和唯一性的场景，如：

- **排行榜**：可以将用户的分数作为有序集合的分数，实现各种排行榜功能。
- **实时热门数据统计**：通过不断更新元素的分数，可以实时统计热门数据。
- **带权重的任务调度**：可以将任务的执行时间戳作为有序集合的分数，实现带权重的任务调度。
- **社交网络**：可以利用Zset实现好友推荐、共同好友等功能。
- **数据过期策略**：将数据的过期时间作为有序集合的分数，实现根据过期时间自动清理数据。

**有序集合命令：**

```
--#添加成员及分数
ZADD key score member
ZADD leaderboard 100 "player1"
ZADD leaderboard 200 "player2"
有序集合 leaderboard 包含 {"player1": 100, "player2": 200}。
--#获取成员分数
ZSCORE KEY MEMBER
ZSCORE leaderboard "player1"
返回 100。

```

### 1.8、常用命令

- **设置键值对：**SET KEY VALUE

  ```
  SET name "Alice"
  ```

  设置键 `name` 的值为 `"Alice"`。

- **获取键值：**GET KEY

  ```
  GET name
  ```

  返回 `"Alice"`。

- **删除键：**DEL

  ```
  DEL name
  ```

- **检查键是否存在：**EXISTS KEY

  ```
  EXISTS name
  ```

  返回 `1` 表示存在，`0` 表示不存在。

- **设置键的过期时间：**EXPIRE

  ```
  EXPIRE temp 60
  ```

  设置键 `temp` 的值为 `"value"`，并在 60 秒后自动删除。

- **查看键值生存时间：**TTL

  ```
  TTL temp
  ```

  返回 `temp` 键的剩余生存时间（秒）。

- **开启事务：**MULTI

  ```
  MULTI
  SET user1 "Alice"
  SET user2 "Bob"
  EXEC
  ```

  将 `user1` 设置为 `"Alice"`，将 `user2` 设置为 `"Bob"`，并提交事务。

- **获取所有键：**KEYS pattern

  ```
  KEYS *
  ```

- **清空当前数据库：**FLUSHDB

  清空当前选择的数据库中的所有键。

## 二、Redis基础原理

### 2.1、redis为什么那么快？

- **内存存储：**所有数据存储在内存中，读取速度极快。
- **单线程模型：**避免了多线程上下文切换开销。
- **高效的数据结构：**使用了优化的数据结构，如字典、跳表等。
- **I/0多路复用：**使用epoll等机制高效处理大量客户端连接。
- **网络协议优化：**采用了高效的通信协议，减少数据传输开销。

### 2.2、为什么那么快不拿来做数据库呢？

- **内存限制：**数据存储在内存中，内存容量限制了存储量，不适合大规模持久化数据。
- **数据持久化：**虽然支持持久化，但是数据量大时恢复速度较慢，可靠性不如传统的数据库。
- **事务支持有限：**事务功能简单，缺乏复杂的事务管理和回滚机制。
- **单线程瓶颈：**单线程模型虽然高效，但在高并发场景写可能成为瓶颈。

### 2.3、有序集合用什么数据结构来实现的？

- 通过跳表数据结构实现的，跳表是一种快速增删改查的数据结构，心能接近于平衡树，但实现维护更简单，每个有序元素还会关联一个分数，用于确定元素在集合中的顺序。

### 2.4、什么是字典（哈希表）？什么是跳表（skip List）？

- **字典：**通过字典，可以在O1时间复杂度内根据成员名称快速找到对应的分数。
- **跳表：**跳表支持高效的范围查询和有序操作如增删改查，这些操作时间复杂度为0logN。

### 2.5、SQL和NOSQL 怎么保持数据一致？

**写入后同步**：

- 在对 MySQL 进行写操作（如插入、更新、删除）后，立即更新 Redis 中的相应数据。这种方式确保 Redis 中的数据与 MySQL 同步。

**缓存失效**：

- 在更新 MySQL 后，主动删除 Redis 中的缓存数据。下次访问时，系统会重新从 MySQL 中加载数据并更新缓存。

**使用消息队列**：

- 通过消息队列（如 RabbitMQ、Kafka）来异步处理数据更新。当数据在 MySQL 中发生变化时，发送消息到队列，消费端根据消息更新 Redis。

**定期同步**：

- 定时任务定期从 MySQL 中同步数据到 Redis，适合数据更新不频繁的场景。

**版本控制**：

- 在 Redis 中维护版本号或时间戳，在每次更新时比较版本，以决定是否更新缓存。

### 2.6、Redis淘汰策略

1. **noeviction：**达到内存最大限制时，禁止写入操作，返回错误，默认策略。
2. **allkey-lru：**所有key，无论是否设置过期时间，当需要释放内存时，最近最少访问的key，优先删除，以便腾出新空间。
3. **volatile-lru：**仅对设置了过期时间的键采用 LRU 淘汰策略。
4. **allkeys-random：**随机删除key释放内存。
5. **volatile-random：**随机删除一个设置过期时间的key释放内存。
6. **volatile-ttl：**优先删除即将过期的key，选择过期时间最短的key。
7. **allkeys-lfu**：在所有键中使用最不常用（LFU）算法淘汰键。
8. **volatile-lfu**：仅对设置了过期时间的键使用 LFU 淘汰策略。

**LRU 原则**：需要释放内存，Redis查找最近最少访问Key，优先删除Key，释放空间。

**LFU 原则**：缓存淘汰算法，优先淘汰使用最低的Key，追踪数据的访问次数次数定义淘汰。

### 2.7、Redis如何处理高并发？

Redis 使用单线程模型和事件循环机制，支持高并发访问，且所有命令都在内存中执行，因此性能非常高。

### 2.8、Redis是单线程还是多线程

单线程，单一主线程执行命令，这种设计有助于简化并发控制和数据一致性，避免了多线程下可能出现的复杂性和竞争条件。

- **事件驱动模型：**Redis使用时间循环机制，能够高效地处理I/0操作，减少等待使时间。
- **内存操作：**大部分操作内存中进行，速度快。
- **管道化：**支持管道技术，允许客户端在一次网络中发送多个命令，减少往返延迟。

**备注：**某些版本也引入的多线程支持，但核心命令的编写还是单线程。

### 2.9、Redis如何实现高可用？

- **Redis Sentinel（哨兵模式）**

  由于多个Sentinel节点监控从Redis 实例、自动故障检测和主从切换，提供配置中心和通知机制。

- **Redis Cluster （集群模式）**

   数据分片在多个节点上，每一个分片有主从复制保证高可用，自动故障转移，支持水平拓展，客户端需要支持集群协议，适用于大数据量的场景。

- **主从复制&Keepalived/vip**

  节点故障时通过VIP飘逸到从节点，需要额外脚本监控和切换，实现相对简单。

### 3.0、RDB做快照时数据能修改么？

**详情：**Redis执行RDB快照（生成持久化文件）时，数据时可以被修改的，Redis通过特定的机制来处理这种情况。

- **RDB快照的工作原理**
  
  - **fork（）子进程：**Redis使用操作系统的fork（）创建一个子进程，子进程获取父进程内存数据副本。
  - **写时复制（Copy-On-Writer，COW）：**子进程开始内存数据写入RDB文件，如果父进程（主Redis进程）在此期间修改了数据，操作系统会复制修改的内存页，子进程继续使用原始数据。
  
- ## 对性能和数据一致性的影响

  - **性能影响**：当有大量写操作时，会导致更多内存页被复制可能增加内存使用量（最多可能达到原数据的2倍）
  - **数据一致性**：RDB 文件反映的是 fork() 时刻的内存数据快照快照期间发生的修改不会体现在当前 RDB 文件中但会体现在下一个 RDB 文件或 AOF 日志中。

- **配置文件修改：**

  ```
  save 900 1      # 900秒内有1个key改变则触发RDB
  save 300 10     # 300秒内有10个key改变则触发RDB
  stop-writes-on-bgsave-error yes  # RDB保存出错时停止写入
  rdbcompression yes              # 压缩RDB文件
  ```

### 3.1、RDB快照时会阻塞线程么？

### 3.2、Redis主从复制的原理？

### 3.2、Redis如何实现分布式锁？

- **基本思路：**SETNEX来创建锁，通过过期时间KEY来避免死锁。

### 3.3、Redis如何助力高并发系统

### 3.4、**高效的内存存储与读写**

- Redis 基于 **内存存储**，相比传统数据库（如 MySQL），读取和写入速度更快，通常在 **微秒级**。
- 支持 **数据结构优化**（如哈希表、列表、集合等），减少存储空间，提高访问效率。

### 3.5.、**减少数据库压力（缓存层）**

- 通过 **缓存热点数据**（如用户信息、商品详情等），减少数据库查询压力，提升系统吞吐量。
- 采用 **缓存穿透、击穿、雪崩** 等优化策略，确保高并发时系统稳定。

### 3.6 、**异步队列削峰（消息队列）**

- 使用 **List** 或 **Stream** 作为**消息队列**，处理秒杀、订单等高并发任务，避免数据库被瞬间冲垮。
- 结合 **消费者模型**，异步处理任务，提升系统吞吐能力。

### 3.7、 **分布式锁**

- 通过 **SET NX** 或 **Redisson** 实现 **分布式锁**，避免高并发下的 **超卖、数据竞争** 问题。
- 适用于 **秒杀、库存扣减、分布式任务调度** 等场景。

### 3.8、 **限流与防刷（流量控制）**

- 通过 **令牌桶算法**、**滑动窗口** 机制，限制单位时间内的请求数量，防止**恶意刷接口**。
- 适用于 **登录、抢购、API 保护** 等场景。

### 3.9、 **主从复制 & 哨兵（高可用）**

- 采用 **主从复制** 提供读写分离，提升并发能力。
- 结合 **Sentinel** 或 **Redis Cluster**，提供自动故障转移，保证服务高可用。

### 4.0、**分布式 Session 共享**

- 在 **多台 Web 服务器** 下，使用 Redis 存储 **Session**，避免用户频繁登录，提升用户体验。
- 适用于 **分布式系统、微服务架构**。

### 4.1、 **Lua 脚本优化**

- Redis 内置 **Lua 脚本**，可执行 **多个命令**，减少网络开销，提升执行效率。
- 适用于 **原子操作**（如抢购、库存扣减）等高并发场景。

### 4.2、Redis淘汰策略

1. **noeviction：**达到内存最大限制时，禁止写入操作，返回错误，默认策略。
2. **allkey-lru：**所有key，无论是否设置过期时间，当需要释放内存时，最近最少访问的key，优先删除，以便腾出新空间。
3. **volatile-lru：**仅对设置了过期时间的键采用 LRU 淘汰策略。
4. **allkeys-random：**随机删除key释放内存。
5. **volatile-random：**随机删除一个设置过期时间的key释放内存。
6. **volatile-ttl：**优先删除即将过期的key，选择过期时间最短的key。
7. **allkeys-lfu**：在所有键中使用最不常用（LFU）算法淘汰键。
8. **volatile-lfu**：仅对设置了过期时间的键使用 LFU 淘汰策略。

**LRU 原则**：需要释放内存，Redis查找最近最少访问Key，优先删除Key，释放空间。

**LFU 原则**：缓存淘汰算法，优先淘汰使用最低的Key，追踪数据的访问次数次数定义淘汰。

### 4.3、Redis用Stenext做分布式锁有什么问题？

1. 如果加锁得线程在加锁后执行得时间较长，而锁得超时时间设置得短，可能导致业务代码还没执行完锁，被释放并且当线程执行完后，如果没有给key设置唯一ID，可能导致该线程释放了其他线程锁。

2. 如果加锁的线程在加锁后没有及时解锁，也没有设置超时时间，如果客户端奔溃，可能导致死锁。

3. setnex不支持锁的可重入，可以借助redission对锁的封装来实现。

4. 由于setnext，命令是对key的操作，每次只有一个线程在执行业务逻辑，所以在高并发的情况下，多个客户端仍在竞争，从而影响性能。

   **总结：**不可重入，直接使用redission。

### 4.4、Redis令牌桶限流算法

- **功能实现：**一种浏览控制算法，用于限制请求速率防止流量过载，通过INCREXP

### 4.5、Redis内存满了怎么办？

1. 查看内存使用情况

   ```redis
   INFO memory
   ```

2. 清理无用数据、批量删除

3. 设置过期时间

4. 增加最大内存限制

   ```
   maxmemory 256mb         # 改大内存上限
   maxmemory-policy allkeys-lru   # 设置淘汰策略
   ```

5. 使用合适的淘汰策略（推荐）

6. 吃计划数据到磁盘：AOF ,RDB

7. 分布式扩容

### 4.6、Redis的线程模型

### 4.7、Redis事务的理解

4.8、如果有大量的key需要设置同一时间过期，一般需要注意什么？

4.9、什么情况下会导致Redis阻塞

5.0、如何解决Redis的Key冲突？

5.1、Redis常见性能问题和解决方案有那些

